## Burpsuite 简单原理
- BurpSuite是一个集成化的跨平台的渗透测试工具, 它集合了多种渗透测试组件, 使我们自动化地或手工地完成对wenb应用的渗透测试和攻击
- 拦截所有通过代理的网络流量, 并可以查看, 修改和转发捕获到的报文
- 一般情况下，客户端（浏览器）会向服务端（web服务）发起请求。
- 在二者中间添加proxy（代理服务器，中间人），中继二者之间的通讯。
- burpsuite即是代理服务器，使客户端先向代理服务器（burp拦截接管的一个回环地址端口）发送请求，用户可以对包进行查看和修改后再转发到服务端，返回的内容同理。
- burpsuite是应用层代理，代理http/https请求
- **Intercept Client Requests**：拦截客户端请求，并设置过滤条件
- **Intercept Server Responses**：拦截服务器响应，中间人攻击时使用
- 使用时，设置浏览器代理插件，使浏览器发送的请求对应burp接管的回环地址端口，使burp接收到并代理请求

### 安装Burpsuite
- 需要依赖JAVA8环境: [JAVA环境安装配置 - 蚁景网安学院](https://edu.hetianlab.com/post/6)
- 从高版本更换Java8: [在Windows环境配置多版本Java](https://blog.csdn.net/weixin_44072270/article/details/117897967)
#### https证书
- 对于https协议的网页，需要给浏览器安装对应的证书后才能进行抓包
- 在burpsuite的Proxy->Option->export CA certificate处导出.der证书，在浏览器的证书信息处选择安装
#### firefox抓包问题
- 在浏览器输入`about:config`，搜索`notwork.captive-portal-service.en`，将值修改为false

### 浏览器代理
- 浏览器安装SwitchyOmega插件, 设置浏览器代理
- 将浏览器代理设置为`127.0.0.1:8080` (Burp默认), 做到对web浏览器的流量拦截, 并对经过BurpSuite的流量进行抓包
- 打开BurpSuite, 点击proxy, `intercept is on`开始抓包

### 模块
- *Dashboard 仪表盘*: 显示Burp工作信息
- *Target 目标*: 显示目标目录结构
- *Proxy 代理*: 拦截HTTP(S)的代理服务器, 最为一个在浏览器和目标应用程序之间的中间人, 允许用户拦截, 查看和修改在两个方向上的原始数据流(请求和响应)
- *Intruder 入侵*: 定制的高度可配置的工具, 对web应用程序进行自动化攻击, 如: 枚举标识符, 收集有用的数据, 使用fuzzing技术探测常规漏洞
	- 对标记变量一次进行爆破
	- 对多个变量同时破解
	- 每一个变量对应一个字典
	- 组合爆破, 每个变量对应一个字典, 并交集爆破
- *Repeater 中继器*: 靠手动操作来触发单独的HTTP请求, 并分析应用程序响应 (修改请求包再重新请求)
- *Sequencer 会话*: 分析不可预知的应用程序会话令牌和重要数据项的随机性
- *Decoder 解码器*: 手动执行或对应用程序数据者智能解码编码
- *Comparer 对比*: 通过一些相关的请求和响应得到两项数据的可视化"差异"
- *Extender 扩展*: 加载BurpSuite的扩展, 使用用户或第三方代码来扩展功能
- *Project options & User options*: 设置


---

## 网络协议分层
为了兼容所有在网络上参与通信工作的不同制式的设备, 同时易于理解和学习, 网络协议由上到下分为五层(TCP/IP模型)
- 应用层
- 传输层
- 网络层
- 数据链路层
- 物理层

OSI模型将应用层分为了应用层, 表示层, 会话层
wireshark工具可以抓包, 查看到每一层段/报文/信息帧的内容

### 应用层
应用软件在应用层实现, 应用层只用专注于为用户提供应用功能, 不用关心数据如何传输, 就像寄快递, 将包裹交给快递员, 后续的流程和实现无需关心. 

应用层工作在操作系统中的用户态, 传输层及以下则工作在内核态

### 传输层
传输层接收来自应用层的数据包, 为不同的应用层应用提供网络支持. 其中有两个主要的传输协议: TCP和UDP

- TCP协议
传输层控制协议(Transmission Control Protocol), 是三次握手的可靠传输, 被大部分应用使用如: HTTP应用层协议. TCP相比UDP多了很多特性, 比如流量控制, 超时重传, 拥塞控制等, 这些都是为了保证数据包能可靠地传输到目标
- UDP协议
UDP只负责发送数据包, 不保证数据包是否抵达. 但它实时性相对更好, 传输效率高. UDP也可以实现可靠传输, 将TCP的特性在应用层实现即可, 不过要实现到可商用的级别是比较困难的

应用需要传输的数据可能非常大, 直接传输难以控制, 因此当传输层的数据包大小超过*MSS(TCP最大报文段长度)*, 就将数据包分块, 称为*TCP段(TCP segment)*, 当某一个TCP段丢失或损坏, 不必重发整个数据包而是只需重发一个TCP段即可

当设备作为接收方时, 传输层把数据包分发给应用, 使用*端口*用来区分同一台设备上的多个应用. 由于传输层的报文中会携带端口号, 因此接收方可以识别出该报文应发送给哪个应用

对于端口, 80端口通常为Web服务器使用, 22端口通常用作远程登录服务器. 而对于浏览器(客户端)中的每个标签栏都是一个独立的进程, 操作系统会为它们分配临时端口号

### 网络层
网络层(Internet Layer)负责将数据从一个设备传输到另一个设备, 在各种各样的路径和节点之间选择. *路由器*是最典型的三层网络设备

网络层最常用是*IP协议(Internet Protocol)*, IP协议会将传输层的报文作为数据部分, 再加上IP包头组装成IP报文, 如果IP报文大小超过MTU(以太网中一般为1500字节)就会进行分片
![[Pasted image 20220830163828.png]]

#### 寻址
网络层使用*IP地址*给设备进行编号, 对于IPv4协议, **IP地址共32位二进制, 分成每段8位的四段** 配合*子网掩码*, 32位二进制又分为*网络号*和*主机号*, 在匹配时, 先在网络中找到并访问目标的网络号, 再在其子网下根据主机号确定目标主机.
- 网络号: 标识目标主机所属的子网(网段)
- 主机号: 标识在同一子网下的不同主机

#### 路由
实际场景中, 两台设备并不是用一条网线直接连接的, 而是通过很多网关, 路由器, 交换机等网络设备相互连接形成的一个错综复杂的网络. 而最终数据通过哪条路径到达目标, 是在数据包到达每一个网络节点时, 由IP协议的算法决定的.

每一个节点只决定数据包传输到下一个节点经过的路径, 即使发送方和接收方也不可知. 寻址像在导航, 路由像是操作方向盘

### 数据链路层
**数据链路层(Data Link Layer)** 运行在局域网或以太网中, 为网络层提供链路级别传输的服务. 网络中每块网卡都会有一个**唯一的*MAC地址***, 即使更换网络环境也不会改变, *交换机*和*网桥*是最典型的二层网络设备

实际场景中, 网络并不是一个整体而是分为许多小型网络, 所以数据也需要跨网络进行传输, 这就需要有一个设备同时在两个网络当中作为*网关*(拥有两块网卡), 负责交换内网和外网的数据, 这个设备一般是*路由器*, 路由器可以通过计算更新*路由表*得出下一个要去的IP地址(最短路程)

在一个网络内, 获得目的IP地址的路由器通过*ARP协议(记录MAC地址和IP地址对应)* 找到去往目的IP地址的下一跳MAC地址(该设备不一定拥有IP地址), 并从对应的端口转发.

### 物理层
当数据准备要从设备发送到网络时, 需要把数据包**转换成电信号**, 让其可以在物理介质中传输, 这就是*物理层(Physical Layer)*, 主要为数据链路层提供二进制传输的服务


---

## IP协议
- 在TCP/IP模型中位于第三层, 实现主机与之际之间的通信, 也叫点对点通信
### IP地址
IPv4由**32位二进制正整数表示**, 32位以8位为一组分为四组. 表示时, 将每组分别转换为十进制, 之间以`.`隔开, 称为*点分十进制*

IP地址的最大值为2^32=4,294,967,296

#### 分类地址
IP地址分为A-E的5类
- A类地址: 第一位为0, 其后7位为网络号, 余下24位为主机号, 0~127
- B类地址: 前两位为10, 其后14位为网络号, 余下16位为主机号, 128~191
- C类地址: 前三位为110, 其后21位位网络号, 余下8位为主机号, 192~223
- D类地址: 前四位为1110, D类地址为组播(多播)地址
- E类地址: 前五位为11110, 预留使用
![[Pasted image 20220901181414.png]]

其中, 有几种特殊的IP地址
- 主机号全为0: 指定某个网络
- 主机号全为1: 指定某个网络下所有主机, 用于广播
- `127.0.0.1` `localhost`: 环回地址, 使用这个IP或主机名时, 数据包不会流向网络

##### 广播
在同一个链路中相互连接的主机之间发送数据包, 可以分为*本地广播*和*直接广播*
- 本地广播: 在主机所在的本网络内广播
- 直接广播: 在不同网络之间的广播, 由路由器寻址(存在*broadcast storm*安全问题, 一般路由器不会转发)

#### 无分类地址CIDR
IP分类存在许多缺点, 现在使用的CIDR不再有分类地址的概念, 32位的IP地址分为前后两部分, 使用子网掩码区分网络号和主机号

子网掩码: 同样为分为四段的32位二进制, 但值只有1或0. 使用时与IP地址一一对应, 1的部分为网络号, 0的部分为主机号(按位与). 子网掩码表示为一个十进制数, 代表掩码中1的个数, 跟随在点分十进制`/`之后. 可以理解为 **"前\*位属于网络号"**

##### 子网划分
将主机地址分为两个部分: **子网网络地址和子网主机地址**

假设对`192.168.1.0`, 子网掩码`255.255.255.192`进行子网划分
![[Pasted image 20220901191206.png]]

#### 私有IP地址
在A, B, C类地址中, 有一小部分私有IP地址, 允许组织内部自己管理, 自己分配, 不与公共IP地址共用, 因此可以重复存在在不同子网之中
- A类: `10.0.0.0` ~ `10.255.255.255`
- B类: `172.16.0.0` ~ `172.31.255.255`
- C类: `192.168.0.0` ~ `192.168.255.255`
![[Pasted image 20230719201724.png]]

#### 路由控制
*路由控制表*中记录着网络地址与下一步应该发送至路由器的地址, 在主机和路由器上都会有各自的路由器控制表

在发送IP包时, 首先要确定IP包首部中的目标地址, 再从路由控制表中找到与该地址具有**相同网络地址**的记录, 根据该记录将IP包转发给相应的下一个路由器. 如果路由控制表中存在多条匹配目标地址的记录, 选择最长匹配

### IP协议相关技术
- DNS域名解析
- ARP和RARP协议
- DHCP动态获取IP地址
- NAT网络地址转换
- ICMP互联网控制报文协议

#### DNS域名解析
为了方便人类记忆, 日常访问网站时通常使用*域名*, 而计算机使用IP地址. 由*DNS域名解析服务*实现, 在网址和IP地址之间转换

##### 域名层级关系
DNS中的域名以点`.`分隔, 越靠后的位置代表其层级越高, 类似一个树状结构, 如`www.server.com`
- 根DNS服务器
- 顶级域DNS服务器(.com)
- 权威DNS服务器(server.com)
根域的DNS服务器信息保存在互联网中所有的DNS服务器中, 因此, 客户端只要访问任意DNS服务器, 就可以通过它找到根DNS服务器, 从而找到其下的任意一台目标DNS服务器

##### 域名解析
![[Pasted image 20220901220204.png]]

#### ARP与RARP
当需要传输一个IP数据包时, 在确定了源IP地址和目的IP地址后, 就会通过主机的*路由表*确定IP数据包的下一跳, 并确定下一跳的MAC地址, 可以通过*ARP协议*完成
- 主机会通过**广播发送ARP请求**, 其中包含了目的的IP地址
- 所有收到ARP请求的设备都会打开请求包, 并比对包中包含的IP地址和自己的IP地址. 如果一致(它在找我!), 则将自己的MAC地址放入*ARP响应包*并返回给主机
- 主机接收到ARP相应包, 获取目标的MAC地址并缓存
*RARP协议*与ARP协议正相反, **由已知的MAC地址求IP地址**, 前提是需要假设一台网内的*RARP服务器*, 并**在其上注册设备的MAC地址及其IP地址**, 每当需要获取IP地址时以MAC地址向该服务器请求. 一般用在打印机等小型嵌入式设备接入到网络

#### DHCP动态获取IP地址
1. 客户端首先发起*DHCP发现报文(DHCP DISCOVER)* 的IP数据报, 由于客户端暂时没有IP地址, 也不知道DHCP服务器的IP地址, 所以使用**UDP广播通信**, 以`0.0.0.0:68`为源地址, `255.255.255.255:67`为目的地址, 广播到所有网络设备
2. DHCP服务器收到DHCP发现报文, 使用*DHCP提供报文(DHCP OFFER)* 广播响应, 报文信息包含可租约的IP地址, 子网掩码, 默认网关, DNS服务器和IP地址租用期
3. 客户端收到DHCP提供报文后, 向选中的服务器发送*DHCP请求报文(DHCP REQUEST)* , 回显配置的参数
4. 服务端收到DHCP请求报文后, 使用*DHCP ACK*报文响应, 应答所要求的参数

此时交互完成, **全程使用UDP广播通信**. 客户端可以在指定的租用期内使用该IP地址. 在租约快到期时, 客户端会向DHCP服务器再次发送DHCP请求报文, 服务器应答*DCHP ACK*为同意继续租用, *DHCP NACK*不同意继续租用

路由器不会转发广播包, 为了不在每个网络中都配置一个DHCP服务器, 出现了*DHCP中继代理*. **由一个DHCP服务器同一管理不同网段的IP地址分配**
3. 每个网络内有一个*DHCP中继代理(路由器)*, 收到客户端发送的DHCP请求包后, 以**单播**的形式转发给DHCP服务器
4. 服务器收到该包后像中继代理返回应答, 并由中继代理转发给客户端

#### NAT网络地址转换
在内网的主机对外部通信时, 把私有IP地址转换成公有IP地址
网关路由器使用*NAPT转换表*, 把内网的`IP:PORT`绑定到一个新的端口号, 并以网关的固定公网IP向目的IP转发
在TCP情况下, 连接建立(发出SYN)就会在转换表中生成对应的映射对, 连接关闭(发出FIN)时自动删除

#### ICMP互联网控制报文协议
Internet Control Message Protocol, 在IP通信中如果某个IP包因为某种原因未能达到目标地址, 那么这个具体的原因将由ICMP负责通知, 可以大致分为两类
- 用于诊断的查询信息 `查询报文类型`
- 通知出错的原因的报错信息 `差错报文类型`
![[Pasted image 20220902162207.png]]

---

## BurpSuite的使用
- BurpSuite是一个集成化的跨平台的渗透测试工具, 它集合了多种渗透测试组件, 使我们自动化地或手工地完成对wenb应用的渗透测试和攻击
- 拦截所有通过代理的网络流量, 并可以查看, 修改和转发捕获到的报文
- 需要依赖JAVA8环境: [JAVA环境安装配置 - 蚁景网安学院](https://edu.hetianlab.com/post/6)
- 从高版本更换Java8: [在Windows环境配置多版本Java](https://blog.csdn.net/weixin_44072270/article/details/117897967)

### 浏览器代理
- Edge浏览器安装SwitchyOmega插件, 设置浏览器代理
- 将浏览器代理设置为`127.0.0.1:8080` (Burp默认), 做到对web浏览器的流量拦截, 并对经过BurpSuite的流量进行抓包
- 打开BurpSuite, 点击proxy, intercept is on开始抓包

### 证书安装
- 通常情况下只抓http包, https需要证书才能正常抓取
1. 在打开代理的情况下访问`http://burp`, 点击右侧的"CA Certificate"下载证书
2. 在浏览器的设置中, 添加此下载的证书`Postswagger CA`

### 模块
- *Dashboard 仪表盘*: 显示Burp工作信息
- *Target 目标*: 显示目标目录结构
- *Proxy 代理*: 拦截HTTP(S)的代理服务器, 最为一个在浏览器和目标应用程序之间的中间人, 允许用户拦截, 查看和修改在两个方向上的原始数据流(请求和响应)
- *Intruder 入侵*: 定制的高度可配置的工具, 对web应用程序进行自动化攻击, 如: 枚举标识符, 收集有用的数据, 使用fuzzing技术探测常规漏洞
	- 对标记变量一次进行爆破
	- 对多个变量同时破解
	- 每一个变量对应一个字典
	- 组合爆破, 每个变量对应一个字典, 并交集爆破
- *Repeater 中继器*: 靠手动操作来触发单独的HTTP请求, 并分析应用程序响应 (修改请求包再重新请求)
- *Sequencer 会话*: 分析不可预知的应用程序会话令牌和重要数据项的随机性
- *Decoder 解码器*: 手动执行或对应用程序数据者智能解码编码
- *Comparer 对比*: 通过一些相关的请求和响应得到两项数据的可视化"差异"
- *Extender 扩展*: 加载BurpSuite的扩展, 使用用户或第三方代码来扩展功能
- *Project options & User options*: 设置

---

## HTTP协议
*HTTP超文本传输协议(HyperText Transfer Protocol)*, 是一种用于分布式, 协作式和超媒体信息系统的应用层协议. **是基于请求与响应, 无状态的, 应用层协议**, 用于*TCP/IP协议*传输数据, 是互联网上应用最为广泛的一种网络协议, 所有互联网文件必须遵守这个标准. http默认端口号80, https默认端口号443

- 协议: 它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范(**两个以上的参与者**), 以及相关的各种控制和错误处理方式(行为约定和规范)
- 传输: HTTP是一个双向协议, 专门用来约定和规范**在两点之间传输数据**的行为
- 超文本: HTTP的传输内容是"超文本", 就是**超越了普通文本的文本**, 是文字, 图片, 视频, 压缩包等的混合体. 超链接从一个超文本跳转到另外一个超文本. 如: HTML
- 无状态: 请求消息和响应消息一一对应, 每次请求相互独立, 有一个请求就有一个响应

**HTTP是一个在计算机世界里专门在"两点"之间"传输"文字, 图片, 音频, 视频等"超文本"数据的"约定和规范"

### 统一资源定位符URL
Uniform Resource Locator, 统一资源定位符, 也就是常说的网址, 遵守一种标准的语法, 它由协议, 主机名, 域名, 端口, 路径, 文件名六部分组成
`protocal://[[user[:password]@]host[:port]][/path][?query][#fragment]`
- `protocol` 指定使用的传输协议
	- `http/https`: 定位网络资源
	- `mailto`: 用户打开邮箱的客户端
	- `ftp`: 用来做文件的转换
	- `file`: 读取文件
- `user:password`: 需要认证后才能访问时的账号密码
- `host`: 合法的因特网主机域名或IP地址
- `port`: 在传输层上交换信息的进程端口号, 标明了获取服务器资源的入口
- `?query`: 给动态网页传递参数, 键值形式用`=`分隔, 可以有多个, 用`&`隔开
- `#fragment`: 信息片段字符串, 用于指定网络资源中的锚点片段, 一般与<\a>

### 统一资源标识符URI
Universal Resource Identifier, 用来标识抽象或物理资源的一个紧凑字符串. HTTP协议使用URI来传输数据和建立连接. 

URL(统一资源定位符)是URI的子集, 用来标识互联网资源,  并指定对其进行操作或获取该资源的办法

URN(统一资源名称)是URI的子集, 通过特定命名空间中的唯一名称或ID来标识资源, 用来定义某事物的身份, 不指定地址

### HTTP客户端请求消息/服务端响应消息
##### 请求消息-request
![[Pasted image 20220905185116.png]]
1. 请求行
	- `请求方法(method)`[[网络协议基础#请求方法|请求方法]]
		- 8种, 常见的是GET和POST, 在控制台的网络查看
		- GET: 请求参数在URL地址中, URL有长度限制, 只能传输字符数据
		- POST: 请求参数在请求体中, 无大小限制, POST请求可以传输字符或字节数据
	- `Request-URI`: 要请求的[[#统一资源标识符URI|URI资源标识符]]
	- 协议及协议版本
1. 请求头: 除`HOST`外, 都是可选的. 详见[HTTP headers - HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
	- `HOST`: 目标请求主机域名/IP地址
	- `User-Agent`: 告诉服务器浏览器版本信息, 供服务器解决浏览器兼容问题
	- `Accept`: 传输文件类型
	- `Referer`: 告诉服务器从哪里来 (跳转来源)
	- `Cookie`: 储存在用户本地终端上的数据
	- `Connection`: 客户端要求服务器使用TCP持久连接, 指定`Keep-Alive`
	- `Content-Type`: (POST) 以[[#MIME类型|MIME类型]]描述请求体的格式, 详见 [HTTP Content-type](http://tools.jb51.net/table/http_content_type)
	- `Content-Length`: 在定义Content-Type之后, 显示请求体的字符长度
	- `Origin`: 当前请求来自于哪个站点
	- `X-Requested-With`: Ajax异步请求
	- `Accept-Encoding`: 指定浏览器可支持的web服务器返回内容压缩编码类型
	- `Accept-Language`: 指定浏览器可接受的语言
2. 请求空行: 用来分隔请求头和请求体
3. 请求体(正文): 可以没有, 但是必须要有一行空着
	- GET: 提交数据时, 数据参数会**作为URL的一部分**, 以`?`放在URL路径后面发送给服务器, 称为*查询字符串*
	- POST: **发送的数据在请求体中**


##### 响应消息-response
![[Pasted image 20230626153838.png]]
1. 状态行
	- 协议及版本
	- 响应状态码&状态码描述, 详见[HTTP状态码-RUNOOB](https://www.runoob.com/http/http-status-codes.html), [HTTP状态码对照表-jb51.net](http://tools.jb51.net/table/http_status_code)
		- 1xx: 提示信息, 表示目前是协议处理的中间状态, 还需要后续的操作
		- 2xx: 成功, 报文已经收到并被正确处理
			- `200 OK`成功
			- `204 No Content` 成功, 无body数据
			- `206 Partical Content` 成功, 非全部资源
		- 3xx: 重定向, 资源位置发生变动, 需要客户端重新发送请求
			- `301 Moved Permanently` 永久重定向, 使用新的URI替代
			- `302 Found` 临时重定向, 依旧使用原有URI
			- `304 Not Modified` 未修改, 服务器不会返回任何资源. 客户端通常会缓存访问过的资源, 通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
			- `307 Temporary Redirect` 临时重定向, 使用GET重定向
		- 4xx: 客户端错误, 请求报文有误, 服务器无法处理
			- `400 Bad Request` 客户端请求的语法有误, 服务器无法解析
			- `403 Forbidden` 访问被拒绝, 可以更改源ip为127.0.0.1绕过
			- `404 Not Found` 没有找到对应资源
			- `405 Method Not Allowed` [[#请求方法|请求方式]]不被允许
		- 5xx: 服务器错误, 服务器在处理请求时内部发生了错误
			- `500 Internal Server Error` 服务器内部出现异常
			- `501 Not Implemented` 功能未支持
			- `502 Bad Gateway` 作为网关或代理的服务器, 从远程服务器接收到了一个无效的响应, 一般是远程服务器访问过多导致的
			- `503 Service Unavailable` 由于超载或系统维护, 服务器赞数无法处理客户端的请求, 延时长度可包含在Retry-After头信息中
2. 响应头
	- `Server`: Web服务器软件名称
	- `Data`: 原始服务器消息发出的时间
	- `Content-Type`: 返回内容(响应体)的[[#MIME类型|MIME格式]]
	- `Set-Cookie`: 设置HTTP Cookie
	- `Content-Length`: 响应体的长度
	- `ETag`: 请求变量的实体标签的当前值
	- `refresh`: 重定向或创造新的资源
	- `WWW-Authenticate`: 表名客户端请求实体应该使用的授权方案
	- `Allow`: 指定对某网络资源的有效[[网络协议基础#请求方法|请求行为]], 不允许则返回405
	- `Location`: 指定客户端重定向URL, 一般与`3xx`和`201`状态码一起使用
3. 响应空行: 用于分隔响应头和响应体
4. 响应体
	- 前端源码
	- 传递的参数(ajax)


[[8.1 网络基础协议#HTTP 超文本传输协议]]

#### MIME类型
- MIME(Multipurpose Internet Mail Extensions)是描述消息内容类型的因特网标准, 用来表示文档, 字节或字节流的性质和格式. 在HTTP数据包中在Content-Type头部字段显示
- 常见MIME类型(通用型):
	- 超文本标记语言.html文件: text/html
	- XML文档 .xml: text/xml
	- 普通文本 .txt: text/plain
	- PDF文档 .pdf: application/pdf
	- PNG图像 .png: image/png
	- GIF图形 .gif: image/gif
	- JPEG图形 .jpeg/.jpg: image/jpeg
	- JSON数据 application/json

#### 请求方法
前三种定义于`HTTP1.0`, 后六种在`HTTP1.1`新增
##### GET
请求获取[[#统一资源标识符URI|Request-URI]]所标识的资源

##### POST
在*Request-URI*所标识的资源后附加新的数据, 用于表单提交, 文件上传等
	1. 会随机生成一个很长的`boundary`用于分割不同的字段, 为了避免与正文内容重复
	2. `boundary`会在`Content-Type`字段中指明`multipart/form-data`
	3. 请求体中按照字段个数分为多个结构类似的部分, 每部分都以`------boundary`开始
		1. 每个段中都有*内容描述信息*`Content-Disposition` , 空行, 字段具体内容(文本或二进制), 如果是文件就还要包含*文件名和类型信息*`Content-Type`
	4. 消息主体以`------boundary--`结束
POST常见`Content-Type`: 
	- `application/x-www-form-urlencoded` 浏览器支持的原生form表单
	- `multipart/form-data` 上传文件
	- `application/json` 在响应中常见, 指明消息主题中是序列化后的json字符串
	- `application/octet-stream` 脚本语句

- `HEAD` 请求获取由*Request-URI*所标识的资源的**响应消息报头**, 不会返回报文主体
- `PUT` 请求服务器访问并存储一个资源, 使用*Request-URI*, 不带验证机制
	- URL指定的资源**不存在**, 服务器新建一个文件保存请求体中的内容, 返回`201`
	- URL指定的资源**存在**, 服务器用请求体中的内容完全覆盖文件, 返回`200`或`204`
- `DELETE` 请求服务器删除*Request-URI*所标识的资源, 不带验证机制, 不安全
- `TRACE` 请求服务器回送收到的请求消息, 主要用于测试或诊断
- `OPTIONS` 请求查询服务器的性能, 或者查询与资源相关的选项和需求
- `CONNECT` 保留将来使用, HTTP/1.1中预留给能够将连接改为管道的代理服务器
- `PATCH` 用于将局部修改应用到资源(RFC 5789)


### HTTP与HTTPS
- HTTP是超文本传输协议, 信息是明文传输; 而HTTPS在HTTP和TCP之间加入了*SSL/TLS安全协议*, 使得报文可以**加密传输**
- HTTP连接建立相对简单, 只需要TCP三次握手 而HTTPS在三次握手之后, 还需要进行***SSL/TLS握手***的过程, 才可以进入加密报文的传输
- HTTP默认使用**80端口**, HTTPS默认使用**443端口**
- HTTPS协议需要向CA(Certification Authority)申请数字证书, 以**保证服务器身份可信**

#### SSL/TLS协议
SSL/TLS是一种密码通信框架, 是世界上使用最广泛的密码通信方法, 上面可以承载HTTP/SMTP/POP3等应用层协议
- SSL(Secure Socket Layer)安全套接层, 1994年由Netscape设计
- TLS(Transport Layer Security), 是IETF在SSL3.0基础上设计的协议

![[Pasted image 20220906004823.png]]
TLS主要分为两层, 底层的*TLS记录协议*负责使用对称密码对消息进行加密
上层的是*TLS握手协议*, 分为四个部分
- 使用SSL/TLS通信的双方会先进行*握手协议*, 交互和共享一些必要信息, 同时**商榷共享密钥, 加密算法和交互证书(认证)**
- *密码规格变更协议*: 向通信对象传达变更密码方式的信号
- *警告协议*: 在发生错误时将错误传达给对方
- *应用数据协议*: 将TLS承载的应用数据传达给通信对象的协议